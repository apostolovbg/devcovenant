"""Refresh policies, registry, and profile catalog in one command."""

from __future__ import annotations

from pathlib import Path

import yaml

from devcovenant.core import manifest as manifest_module
from devcovenant.core import profiles
from devcovenant.core.install import (
    GITIGNORE_USER_BEGIN,
    GITIGNORE_USER_END,
    _apply_core_config,
    _apply_profile_config,
    _ensure_custom_tree,
    _ensure_tests_mirror,
    _load_active_profiles,
    _prune_devcovrepo_overrides,
    _render_gitignore,
    _set_backups_enabled,
    apply_autogen_metadata_overrides,
)
from devcovenant.core.refresh_policies import (
    export_metadata_schema,
    policy_metadata_schema_path,
    refresh_policies,
)
from devcovenant.core.update_policy_registry import update_policy_registry


def _schema_path(repo_root: Path) -> Path:
    """Return the schema path used for refresh-policies runs."""
    canonical = policy_metadata_schema_path(repo_root)
    if canonical.exists():
        return canonical
    return (
        repo_root
        / "devcovenant"
        / "core"
        / "profiles"
        / "global"
        / "assets"
        / "AGENTS.md"
    )


def _looks_generated_gitignore(text: str) -> bool:
    """Return True if the gitignore appears generated by DevCovenant."""
    return "# Profile:" in text or "DevCovenant base ignores" in text


def _prepare_gitignore_user_text(existing: str) -> str:
    """Return the user text block for gitignore regeneration."""
    if not existing:
        return ""
    if GITIGNORE_USER_BEGIN in existing and GITIGNORE_USER_END in existing:
        return existing
    if _looks_generated_gitignore(existing):
        return ""
    return existing


def refresh_gitignore(repo_root: Path) -> bool:
    """Regenerate the repo .gitignore from profile fragments."""
    gitignore_path = repo_root / ".gitignore"
    existing = (
        gitignore_path.read_text(encoding="utf-8")
        if gitignore_path.exists()
        else ""
    )
    user_text = _prepare_gitignore_user_text(existing)
    active_profiles = _load_active_profiles(repo_root)
    if "global" not in active_profiles:
        active_profiles.append("global")
    active_profiles = sorted(set(active_profiles))
    template_root = repo_root / "devcovenant" / "core"
    rendered = _render_gitignore(
        user_text,
        repo_root,
        template_root,
        active_profiles,
    )
    if existing == rendered:
        return False
    gitignore_path.write_text(rendered, encoding="utf-8")
    return True


def refresh_config(
    repo_root: Path, profile_catalog: dict[str, dict], include_core: bool
) -> bool:
    """Refresh config.yaml from active profiles while preserving overrides."""
    config_path = repo_root / "devcovenant" / "config.yaml"
    if not config_path.exists():
        return False
    active_profiles = _load_active_profiles(repo_root)
    if "global" not in active_profiles:
        active_profiles.append("global")
    active_profiles = sorted(set(active_profiles))
    changed = _apply_core_config(repo_root, include_core)
    profile_changed = _apply_profile_config(
        repo_root, active_profiles, profile_catalog
    )
    overlay_changed = apply_autogen_metadata_overrides(repo_root)
    return changed or profile_changed or overlay_changed


def refresh_all(
    repo_root: Path | None = None,
    *,
    schema_path: Path | None = None,
    registry_only: bool = False,
    backup_existing: bool = False,
) -> int:
    """Refresh policies, registry, and profile catalog."""
    if repo_root is None:
        repo_root = Path(__file__).resolve().parents[2]
    _set_backups_enabled(backup_existing)
    agents_path = repo_root / "AGENTS.md"
    schema = schema_path or _schema_path(repo_root)
    if registry_only:
        return refresh_registry(repo_root, schema_path=schema)
    result = refresh_policies(
        agents_path,
        schema,
        set_updated=True,
    )
    export_metadata_schema(repo_root)
    if result.changed_policies:
        joined = ", ".join(result.changed_policies)
        print(f"refresh-policies updated metadata for: {joined}")
    if result.skipped_policies:
        print("Skipped policies with missing ids:")
        for policy_id in result.skipped_policies:
            print(f"- {policy_id}")
    policy_result = update_policy_registry(repo_root)
    if policy_result != 0:
        return policy_result
    catalog = profiles.build_profile_catalog(repo_root)
    profiles.write_profile_catalog(repo_root, catalog)
    print("Rebuilt profile catalog at", profiles.REGISTRY_CATALOG)
    include_core = _load_devcov_core_include(repo_root)
    if refresh_config(repo_root, catalog, include_core):
        print("Refreshed config.yaml from active profiles.")
    if refresh_gitignore(repo_root):
        print("Regenerated .gitignore from profile fragments.")
    _ensure_custom_tree(repo_root)
    _ensure_tests_mirror(repo_root, include_core)
    removed_overrides = _prune_devcovrepo_overrides(repo_root, include_core)
    if removed_overrides:
        manifest_module.append_notifications(
            repo_root,
            [
                (
                    "Removed devcovrepo-prefixed overrides:"
                    f" {', '.join(removed_overrides)}"
                )
            ],
        )
    return 0


def refresh_registry(
    repo_root: Path | None = None,
    *,
    schema_path: Path | None = None,
) -> int:
    """Refresh only registry assets without touching AGENTS or docs."""
    if repo_root is None:
        repo_root = Path(__file__).resolve().parents[2]
    # Regenerate schema to keep descriptors aligned.
    export_metadata_schema(repo_root)
    # Update registry hashes/metadata without toggling AGENTS updated flags.
    result = update_policy_registry(
        repo_root, skip_freeze=True, reset_updated_flags=False
    )
    if result != 0:
        return result
    # Rebuild profile catalog (lives under registry/local/, gitignored).
    catalog = profiles.build_profile_catalog(repo_root)
    profiles.write_profile_catalog(repo_root, catalog)
    print("Registry-only refresh completed (schema, hashes, profile catalog).")
    return 0


def _load_devcov_core_include(repo_root: Path) -> bool:
    """Return devcov_core_include from config.yaml when present."""
    config_path = repo_root / "devcovenant" / "config.yaml"
    if not config_path.exists():
        return False
    try:
        payload = yaml.safe_load(config_path.read_text(encoding="utf-8")) or {}
    except Exception:
        return False
    if not isinstance(payload, dict):
        return False
    return bool(payload.get("devcov_core_include", False))


def main() -> int:
    """CLI entry point."""
    return refresh_all()


if __name__ == "__main__":
    raise SystemExit(main())
